\section{Tools}
\label{sec:tools}

\subsection{Shell scripts}
\label{sec:undervolt-test.sh}

The columnsep is \the\columnsep. The script used in §\ref{sec:unstableOPPs} to assist us in collecting data
regarding which OPPs result in a system crash is given in Listing
\ref{lst:undervolt-test.sh}.

\lstinputlisting[language=Bash,
    breakatwhitespace=false,
    caption={\label{lst:undervolt-test.sh}
    Shell script to determine critical points — \code{undervolt-test.sh}}]
    {undervolt-test.sh}

The script takes the frequency to test in MHz as its first argument, e.g.
\code{2600} for 2600 MHz, and optionally takes a second argument, \code{all}.
If \code{all} is specified, we test all voltage offsets listed in the file
\code{undervolt-list.txt}, which simply lists all the multiples of 10 in order
from $-10$ to $-400$, as can be seen in Listing \ref{lst:undervolt-list.txt}
for clarity.

If \code{all} is not specified, a list of voltage offsets specific
to the given frequency is used, as found in the file
\code{undervolt-list-\textit{f}.txt}, where \code{\textit{f}} is the given
frequency. For example, specifying \code{2600} as the frequency and not
specifying \code{all} will result in the file \code{undervolt-list-2600.txt}
being used as the list of voltage offsets to test. The voltage offsets given in
such files are expressed in milivolts, as they will be passed directly to the
\code{undervolt} utility, which expects voltage offsets in these units, as
explained in §\ref{sec:undervolt}.

\lstinputlisting[language=C,
    caption={\label{lst:undervolt-list.txt}
    Imprecise list of voltage offsets to test for all frequencies, in
    millivolts — \code{undervolt-list.txt}}]
    {undervolt-list.txt}

\subsection{Kernel modules}

[TBD]

We create a custom \code{sha1sum} binary which changes the core voltage during its
execution.
Need to execute in kernel mode so that MSRs can be read/written in order to
change the voltage.
We create a custom kernel module for this purpose which computes SHA-1 hash
when inserted into the kernel via \code{insmod}.

====

In order to demonstrate that it is possible to use a \clkscrew{} style attack
on this platform, we attempt to compute an incorrect SHA-1 hash of some data.
The process is as follows:

\begin{enumerate}
    \item Choose a known critical point.
    \item Put the system into a stable OPP near the chosen critical point.
    \item Begin computing the SHA-1 hash.
    \item Whilst the hash is being computed, temporarily put the system into an
        unstable OPP near the chosen critical point.
    \item The hash computation ends, and we hope to see an incorrect hash.
\end{enumerate}

To conduct this process, an attacker would need access to read from and write to
the necessary MSR. This is ultimately done via execution of the assembly-level
\code{RDMSR} and \code{WRMSR} instructions of the x86
architecture~\cite[Vol. 2, §§4.3–4]{intelDevManual}. Since these instructions
must be executed at privilege level 0 or in real-address mode, we cannot
execute these instructions from userspace; we need to do so in kernel mode. We
therefore write a custom kernel driver to set the OPP at the necessary times.

For the sake of simply forming a proof-of-concept that computational faults can
occur, rather than actually producing a fully-formed attack, we adapt the source
code of GnuPG's \code{sha1sum} program~\cite{gnupgSHA} into a kernel module
which, upon being inserted into the kernel via \code{insmod}, computes the
SHA-1 hash of a file with a predefined filepath (namely
\code{/tmp/.\_shatest\_data}), and logs the computed hash to the console. We
adapt some code by Michael Guyver~\cite{guyverCode} to develop a set of C
functions which can read from and write to the MSRs appropriately in order to
set the core voltage offset as required. We then alter the hash computation code
so that the system is temporarily put into an unstable OPP as in step (3) above.

To this end, we have written a kernel module dubbed \code{bad\_sha}, which is
given in Listing \ref{lst:bad-sha.c}. The header file \code{msr.h} which
contains the functions for reading from and writing to MSRs is given in
Listing \ref{lst:msr.h}

\lstinputlisting[language=C,
    caption={\label{lst:bad-sha.c}
    Source code for the \code{bad\_sha} kernel module — \code{bad-sha.c}}]
    {bad-sha.c}

\lstinputlisting[language=C,
    caption={\label{lst:msr.h}
    Header file containing MSR-related functions — \code{msr.h}}]
    {msr.h}
